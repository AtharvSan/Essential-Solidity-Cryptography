// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

/* what computation to be placed onchain and what to be done offchain @todo */

/* cryptography native properties @todo */
// - uniqueness
// - data identifier
// - deterministic
// - speed
// - anonymity
// - random output (no guessing)
// - non reversibility
// - snowball effect
// - locking
// - unlocking
// - keys and locks
// - proof of order (signatures)
// - verification of signatures


/* */ 
contract cryptography_cheatsheet {
    // State vars ////////////////////////////////////////////////////
    /* 5 ------- */
    address multisig = address(new MultiSig());

    /* 6 ------- */
    address alice = address(0x2);
    address bob = address(0x3);




    // Notes and Functions ///////////////////////////////////////////
    /* 1. Hash functions --------------------------------------------*/
    // - the problem : data is sometimes too big its hard to point out the exact data(if the data be corrupted)
    // - the solution : the data is shortened down to few bytes, now its way easier to give reference to exact data
    // - implementation : keccak256(bytes data) --> bytes32
    // - properties (specially engineered features) :
    //      - collision resistance : unique and short output
    //      - fast to compute
    //      - deterministic : same input will always give same output
    //      - avalanche effect : small change in input will result in completely different output
    //      - pre-image resistance : given output, very hard to find input that gives that output
    //      - fixed output size : always gives same size output
    bytes32 internal ATHARVSAN = keccak256("atharvsan"); 


    /* 2. Encryption ------------------------------------------------*/
    // - the problem : communications can be intercepted
    // - the solution : develop a 'lock and key' system to protect the communication from interception
    // - implementation : OFFCHAIN encryption by wallets


    /* 3. Elliptic Curves -------------------------------------------*/
    // - the problem : strangers not able to open the encrypted lock
    // - the solution : seperation of keys for locking and opening. Anyone can lock but only the reciever can open.
    // - pvt key :
    //      - randomly generated 256-bit key using random number generator from the OS
    //      - opens the encrypted lock
    //      - creates a signature
    // - pub key :
    //      - generated by doing elliptic curve multiplication on the pvt key
    //      - closes the encryption lock
    // - implementation : OFFCHAIN key computation using the secp256k1 curve


    /* 4. Signatures ------------------------------------------------*/
    // - trivia : 
    //      - signatures are created offchain, so this is a gasless process.
    // - the problem : secure communication with strangers became possible, but no info on who sent the message
    // - the solution : sender sends his signature along with the data
    // - signature(bytes32 r, bytes32 s, uint8 v) is a 65-byte data created by ECDSA using data and pvt key
    // - how it is done : 
    //      - signatures are created OFFCHAIN using ECDSA(ethersjs), but verification can be done onchain with ecrecover
    //      - standard transactions : <RLPdata,r,s,v> generated by wallets
    //      - presigned transactions : <signed_data,r,s,v> 
    //          - create signed_data according to eip191
    //          - ECDSA(signed_data,pvt_key) --> v,r,s


    /* 5. EIP191 signed_data standard --------------------------------*/
    // - essential trivia :
    //      - signed_data : the data on which the signature is created
    //      - presigned txns : a chunk of binary 'signed_data', along with the signature(r,s,v)
    //      - txn : RLP<nonce, gasPrice, startGas, to, valve, data>, r, s, v
    //      - helps in verification of off-chain signatures in ethereum ecosystem
    // - the problem: 
    //      - presigned txn getting confused with standard txns as there was no standard to differentiate in 'signed_data' and 'RLPdata'
    //      - the signed_data was not standardized, caused confusion in verification
    // - the solution: 
    //      - setting a standard for differentiating 'signed_data' from 'RLPdata' (initiate with 0x19)
    //      - creating a standard scheme for 'signed_data', to avoid confusion while verifying
    // - implementation :
    //      - signed_data = hash(encodePacked( 0x19 | version | version_data | data_to_sign ))
    //
    //          0x19 | 0x00   | intended validator | data to sign
    //          0x19 | 0x01   | domainSeperator    | hashStruct(message)
    //          0x19 | 0x45(E)| thereum Signed Message:\n"+len(message) | data to sign
    //
    function Signed_data00() view public returns(bytes32 signed_data00){
        bytes memory data00 = "yo..";
        // signed_data00 = 0x19 || 0x00 || validator address || data00
        signed_data00 = keccak256(abi.encodePacked(hex"1900",address(multisig), data00));
    }

    function Signed_data45() pure public returns(bytes32 signed_data45) {
        bytes memory data45 = "Hello ji";
        // signed_data45 = 0x19 || 0x45 || "thereum Signed Message:\nlen(data)" || data45
        signed_data45 = keccak256(abi.encodePacked(hex"1945","thereum Signed Message:\n8",data45));
    }


    /* 6. EIP712 structured data hashing and signing -----------------*/
    // - the problem : complex data structures are hard to sign and verify
    // - the solution : 
    //      - create a standard for hashing and signing structured data
    //      - this helps offchian tools to better understand the onchain data
    // - implementation :
    //      - create a struct of EIP712Domain and data
    //      - create a hashStruct of EIP712Domain and data
    //          - typehash
    //          - encodeData: hashvalues of dynamic types like strings and bytes, direct values for fixed types
    //      - create signed_data01 
    //      - sign the hash
    // - properties
    //      - domainSeperator should be unique to the contract and chain to prevent replay attacks from other domains, and satisfy 
    //        the requirements of EIP-712, but is otherwise unconstrained.
    struct EIP712Domain {
        string name;
        string version;
        uint256 chainId;
        address verifyingContract;
        bytes32 salt;
    }
    struct Mail { //@todo include all of the datatypes for showcasing encoding scheme
        string subject;
        address to;
        address from;
        uint256 nonce;
    }
    function Signed_data01() view public returns(bytes32 signed_data01) {
        // signed_data01 = 0x19 || 0x01 || domainSeperator || hashStruct
        bytes32 typeHash_eip712domain = keccak256("EIP712Domain(string name, string version uint256 chainId, address verifyingContract, bytes32 salt)");
        bytes32 hashStruct_EIP712Domain = keccak256(abi.encode(
            typeHash_eip712domain, 
            keccak256("name"),
            keccak256("version"),
            1,
            address(this),
            0x1234
            )
        );

        bytes32 typeHash_mail = keccak256("Mail(string subject, address to, address from, uint256 nonce)");
        bytes32 hashStruct_mail = keccak256(abi.encode(
            typeHash_mail,
            keccak256("practice"),
            alice,
            bob,
            0
        ));
        signed_data01 = keccak256(abi.encodePacked(hex"1901", hashStruct_EIP712Domain, hashStruct_mail));
    }


    /* 7. Signature verification @todo */
    // - the problem : signatures creation and verification both are handled at infrasturcture level, but if signatures are handled 
    //   outside the infrastructure, you need to do handle both signature creation and signature verification independently
    // - the solution : create offchain signatures using ECDSA, and include a function in smart contracts that verifies the signature 
    //   using version 00 of eip191
    // - implementation : 
    // - properties : 
    // - use cases :
    function verify(address owner, bytes calldata data, uint8 v, bytes32 r, bytes32 s) public view returns (bool success) {
        bytes32 signed_data = keccak256(abi.encodePacked(hex"1900", address(this), data));
        address signer = ecrecover(signed_data, v, r, s);
        require(signer == owner, "unauthorized");
        return true;
    }


    /* 8. EIP2612 signed approvals for erc20 tokens ------------------*/
    // - trivia
    //      - a practical application of independent signature handling (offchain signature creation and onchain signature verification)
    //      - it de-couples ERC20 from msg.sender(builtin signature handling) by handling signatures independently
    //      - A common use case of permit design pattern has a relayer submit a permit order on behalf of the owner.
    // - the problem : ERC20 operation is attached to msg.sender for its builtin signature handling
    // - the solution : decouple ERC20 from msg.sender by implementing signature handling independently 
    //      - offchain signature creation (v, r, s): ECDSA(signed_data, pvtKey)
    //      - submit the order(owner, spender, value, deadline) and the signature (v, r, s) to relayer that will inititate the permit method on token
    //      - create signed_data that will be used in signer extraction: 191, 712, 2612
    //      - extract signer: ecrecover(signed_data, v, r, s)
    //      - verify if the signature is of owner from the order : require(signer == owner, "don't touch someone else's money")
    //      - perform the approve action i.e update allowance for the given order
    // - implementation : Compliant contracts must implement 3 new functions in addition to EIP-20:
    //      - function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external{
    //            // 1. signer recovery 
    //            // 2. verification
    //            // 3. allowance update 
    //        }
    //      - function nonces(address owner) external view returns (uint)
    //      - function DOMAIN_SEPARATOR() external view returns (bytes32)
    // - pros :
    //      - Gasless approves
    //          - Users can approve token transfers without paying gas fees upfront.
    //          - instead of calling approve(), users sign a message off-chain, which is later submitted by the relayer.
    //      - Uniswap and Aave use EIP-2612 to streamline token approvals
    //          - No need for two transactions (approve() + transferFrom()), improving user experience.
    //          - Ideal for onboarding new users without requiring ETH for gas.
    //      - Security notes
    //          - reducing frontrunning risks
    //          - Uses eip712 domainSeperator, preventing signature malleability issues.
    //          - deadline param prevents issues like "stuck approvals" 
    //          - nonces gives replay protection
    //          - Since the ecrecover precompile fails silently and just returns the zero address as signer when given malformed messages, 
    //            it is important to ensure owner != address(0) to avoid permit from creating an approval to spend “zombie funds” belong 
    //            to the zero address.
    //          - The standard EIP-20 race condition for approvals (SWC-114) applies to permit as well
    //          - If the DOMAIN_SEPARATOR contains the chainId and is defined at contract deployment instead of reconstructed for every signature, 
    //            there is a risk of possible replay attacks between chains in the event of a future chain split.
    mapping(address => mapping(address => uint256)) public allowance;
    mapping(address => uint256) public nonces;
    event Approval(address indexed owner, address indexed spender, uint256 amount);
    function permit(
        address owner, // this owner is the one who owns tokens
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public virtual {
        require(deadline >= block.timestamp, "PERMIT_DEADLINE_EXPIRED");

        // Unchecked because the only math done is incrementing
        // the owner's nonce which cannot realistically overflow.
        unchecked {
            address recoveredAddress = ecrecover(
                keccak256(
                    abi.encodePacked(
                        "\x19\x01",
                        DOMAIN_SEPARATOR(),
                        keccak256(
                            abi.encode(
                                keccak256(
                                    "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"
                                ),
                                owner,
                                spender,
                                value,
                                nonces[owner]++,
                                deadline
                            )
                        )
                    )
                ),
                v,
                r,
                s
            );

            require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNER");

            allowance[recoveredAddress][spender] = value;
        }

        emit Approval(owner, spender, value);
    }
    
    uint256 internal immutable INITIAL_CHAIN_ID = block.chainid;
    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();
    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {
        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();//in case the chain bifurgates, chainids may differ
    }
    function computeDomainSeparator() internal view virtual returns (bytes32) {
        return
            keccak256(
                abi.encode(
                    keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
                    keccak256("MockERC20"),
                    keccak256("1"),
                    block.chainid,
                    address(this)
                )
            );
    }

    // 9. EIP1271 contract signature verification
    // - the problem : Externally Owned Accounts (EOA) can sign messages with their associated private keys, but contracts cannot.
    // - the solution : 
    // - implementation : 
    //      - function isValidSignature() inside signer contract : verifies that the signer is the owner of the signing contract.
    //      - MUST return the bytes4 magic value 0x1626ba7e when function passes.
    //      - MUST NOT modify state
    // - use cases : 
    // - security : 
    //      - signature malleability
    /* implementation of a contract calling isValidSignature() on external signing contract -----------------------*/
    function callERC1271isValidSignature(address _addr, bytes32 _hash, bytes calldata _signature) external view {
        bytes4 result = IERC1271Wallet(_addr).isValidSignature(_hash, _signature);
        require(result == 0x1626ba7e, "INVALID_SIGNATURE");
    }
    

    // 10. commit reveal scheme @todo
    // - the problem : The commit-reveal scheme is essential in blockchain-based applications as it ensures that 
    //   users cannot change their answers once they have submitted them, and prevents others from knowing the answer before the deadline.
    // - the solution : 
    //      - commit
    //      - reveal 
    // - implementation : 
    // - properties : 
    // - use cases : every type of blockchain interaction that requires a wallet signature.
    //      - intent-based trading
    //      - advanced order types

    // 11. merkle trees @todo
    // - the problem : 
    // - the solution : 
    // - implementation : 
    // - properties : 
    // - use cases :

    // 12. randomness generation (chainlink) @todo
    // - the problem : 
    // - the solution : 
    // - implementation : 
    // - properties : 
    // - use cases :

}

contract MultiSig {
    address public owner;

    // - This function should be implemented by contracts which desire to sign messages (smart contract wallets, DAOs, multisignature wallets) 
    // - Applications wanting to support contract signatures should call this method if the signer is a contract.
    function isValidSignature(bytes32 _hash, bytes calldata _signature) external view returns (bytes4) {
        // Validate signatures
        if (recoverSigner(_hash, _signature) == owner) { // this owner is the one who owns this contract
            return 0x1626ba7e;
        } else {
            return 0xffffffff;
        }
    }

    function recoverSigner(
        bytes32 _hash,
        bytes calldata _signature // as (bytes32 r, bytes32 s, uint8 v)
    ) internal pure returns (address signer) {
        require(_signature.length == 65, "SignatureValidator#recoverSigner: invalid signature length");

        uint8 v = uint8(_signature[64]);
        bytes32 r = bytes32(_signature[0:32]);
        bytes32 s = bytes32(_signature[32:64]);

        signer = ecrecover(_hash, v, r, s);
        
        require(signer != address(0x0),"SignatureValidator#recoverSigner: INVALID_SIGNER");

        return signer;
    }
}

interface IERC1271Wallet {
        // bytes4 constant internal MAGICVALUE = bytes4(keccak256("isValidSignature(bytes32,bytes)");
        function isValidSignature(bytes32 _hash, bytes memory _signature) external view returns (bytes4 magicValue);
    }
