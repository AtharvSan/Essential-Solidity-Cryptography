// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

contract cryptography_cheatsheet {
    // 1. Hash functions 
    // - the problem : data is sometimes too big its hard to point out the exact data(if the data be corrupted)
    // - the solution : the data is shortened down to few bytes, now its way easier to give reference to exact data
    // - implementation : keccak256(bytes data) --> bytes32
    // - properties (specially engineered features) :
    //      - collision resistance : unique and short output
    //      - fast to compute
    //      - deterministic : same input will always give same output
    //      - avalanche effect : small change in input will result in completely different output
    //      - pre-image resistance : given output, very hard to find input that gives that output
    //      - fixed output size : always gives same size output

    // 2. Encryption
    // - the problem : communications can be intercepted
    // - the solution : develop a 'lock and key' system to protect the communication from interception
    // - implementation : handled at the infrastructure level

    // 3. Elliptic Curves
    // - the problem : strangers not able to open the encrypted lock
    // - the solution : seperation of keys for locking and opening. Anyone can lock but only the reciever can open.
    // - pvt key :
    //      - randomly generated 256-bit key using random number generator from the OS
    //      - opens the encrypted lock
    //      - creates a signature
    // - pub key :
    //      - generated by doing elliptic curve multiplication on the pvt key
    //      - closes the encryption lock
    // - secp256k1 curve used in Ethereum

    // 4. Signatures
    // - the problem : secure communication with strangers became possible, but no info on who sent the message
    // - the solution : sender sends his signature along with the data
    // - signature(uint8 v, bytes32 r, bytes32 s) is created by ECDSA using data and pvt key
    // - how it is done : 
    //      - standard transactions : <RLPdata,r,s,v> generated by wallets
    //      - presigned transactions : <signed_data,r,s,v> 
    //          - create signed_data according to eip191
    //          - ECDSA(signed_data,pvt_key) --> v,r,s

    // 5. EIP191 signed_data standard
    // - essential trivia :
    //      - signed_data : the data on which the signature is created
    //      - presigned txns : a chunk of binary 'signed_data', along with the signature(r,s,v)
    //      - txn : RLP<nonce, gasPrice, startGas, to, valve, data>, r, s, v
    //      - helps in verification of off-chain signatures in ethereum ecosystem
    // - the problem: presigned txn getting confused with standard txns as there was no standard to differentiate in 'signed_data' and 'RLPdata'
    // - the solution: setting a standard for differentiating 'signed_data' from 'RLPdata'
    //      ---------------------------------------------------
    //      0x19 | 1 byte version | version data | data to sign
    //      ---------------------------------------------------
    //      0x19 | 0x00   | intended validator | data to sign
    //      0x19 | 0x01   | domainSeperator    | hashStruct(message)
    //      0x19 | 0x45(E)| thereum Signed Message:\n"+len(message) | data to sign
    // - signed_data is made in various ways, each with its purpose

    // 6. Signature verification
    // - the problem : 
    // - the solution : 
    // 

    // 7. EIP712 structured data hashing and signing

    // 8. EIP2612 signed approvals for erc20 tokens


}
