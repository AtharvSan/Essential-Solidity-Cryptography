// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

contract cryptography_cheatsheet {
    address alice = address(0x1234);
    address bob = address(0x1235);

    /* Hash functions --------------------------------------------*/
    // - the problem : data is sometimes too big its hard to point out the exact data(if the data be corrupted)
    // - the solution : the data is shortened down to few bytes, now its way easier to give reference to exact data
    // - implementation : keccak256(bytes data) --> bytes32
    // - properties (specially engineered features) :
    //      - collision resistance : unique and short output
    //      - fast to compute
    //      - deterministic : same input will always give same output
    //      - avalanche effect : small change in input will result in completely different output
    //      - pre-image resistance : given output, very hard to find input that gives that output
    //      - fixed output size : always gives same size output
    bytes32 internal ATHARVSAN = keccak256("atharvsan"); 


    // Encryption ------------------------------------------------*/
    // - the problem : communications can be intercepted
    // - the solution : develop a 'lock and key' system to protect the communication from interception
    // - implementation : OFFCHAIN encryption by wallets


    // Elliptic Curves -------------------------------------------*/
    // - the problem : strangers not able to open the encrypted lock
    // - the solution : seperation of keys for locking and opening. Anyone can lock but only the reciever can open.
    // - pvt key :
    //      - randomly generated 256-bit key using random number generator from the OS
    //      - opens the encrypted lock
    //      - creates a signature
    // - pub key :
    //      - generated by doing elliptic curve multiplication on the pvt key
    //      - closes the encryption lock
    // - implementation : OFFCHAIN key computation using the secp256k1 curve


    // Signatures ------------------------------------------------*/
    // - trivia : 
    //      - signatures are created offchain, so this is a gasless process.
    // - the problem : secure communication with strangers became possible, but no info on who sent the message
    // - the solution : sender sends his signature along with the data
    // - signature(uint8 v, bytes32 r, bytes32 s) is created by ECDSA using data and pvt key
    // - how it is done : 
    //      - signatures are created OFFCHAIN using ECDSA(ethersjs), but verification can be done onchain with ecrecover
    //      - standard transactions : <RLPdata,r,s,v> generated by wallets
    //      - presigned transactions : <signed_data,r,s,v> 
    //          - create signed_data according to eip191
    //          - ECDSA(signed_data,pvt_key) --> v,r,s


    // EIP191 signed_data standard --------------------------------*/
    // - essential trivia :
    //      - signed_data : the data on which the signature is created
    //      - presigned txns : a chunk of binary 'signed_data', along with the signature(r,s,v)
    //      - txn : RLP<nonce, gasPrice, startGas, to, valve, data>, r, s, v
    //      - helps in verification of off-chain signatures in ethereum ecosystem
    // - the problem: 
    //      - presigned txn getting confused with standard txns as there was no standard to differentiate in 'signed_data' and 'RLPdata'
    //      - the signed_data was not standardized, caused confusion in verification
    // - the solution: 
    //      - setting a standard for differentiating 'signed_data' from 'RLPdata' (initiate with 0x19)
    //      - creating a standard scheme for 'signed_data', to avoid confusion while verifying
    // - implementation :
    //      - signed_data = hash(encodePacked( 0x19 | version | version_data | data_to_sign ))
    //
    //          0x19 | 0x00   | intended validator | data to sign
    //          0x19 | 0x01   | domainSeperator    | hashStruct(message)
    //          0x19 | 0x45(E)| thereum Signed Message:\n"+len(message) | data to sign
    //
    address multisig;
    function Signed_data00() view public returns(bytes32 signed_data00){
        bytes memory data00 = "yo..";
        // signed_data00 = 0x19 || 0x00 || validator address || data00
        signed_data00 = keccak256(abi.encodePacked(hex"1900",address(multisig), data00));
    }

    function Signed_data45() pure public returns(bytes32 signed_data45) {
        bytes memory data45 = "Hello ji";
        // signed_data45 = 0x19 || 0x45 || "thereum Signed Message:\nlen(data)" || data45
        signed_data45 = keccak256(abi.encodePacked(hex"1945","thereum Signed Message:\n8",data45));
    }


    // EIP712 structured data hashing and signing -----------------*/
    // - the problem : complex data structures are hard to sign and verify
    // - the solution : 
    //      - create a standard for hashing and signing structured data
    //      - this helps offchian tools to better understand the onchain data
    // - implementation :
    //      - create a struct of EIP712Domain and data
    //      - create a hashStruct of EIP712Domain and data
    //      - create signed_data01 
    //      - sign the hash
    // - properties
    //      - domainSeperator should be unique to the contract and chain to prevent replay attacks from other domains, and satisfy 
    //        the requirements of EIP-712, but is otherwise unconstrained.
    struct EIP712Domain {
        string name;
        string version;
        uint256 chainId;
        address verifyingContract;
        bytes32 salt;
    }
    struct Mail { //@todo include all of the datatypes for showcasing encoding scheme
        string subject;
        address to;
        address from;
        uint256 nonce;
    }
    function Signed_data01() view public returns(bytes32 signed_data01) {
        // signed_data01 = 0x19 || 0x01 || domainSeperator || hashStruct
        bytes32 typeHash_eip712domain = keccak256("EIP712Domain(string name, string version uint256 chainId, address verifyingContract, bytes32 salt)");
        bytes32 hashStruct_EIP712Domain = keccak256(abi.encode(
            typeHash_eip712domain, 
            keccak256("name"),
            keccak256("version"),
            1,
            address(this),
            0x1234
            )
        );

        bytes32 typeHash_mail = keccak256("Mail(string subject, address to, address from, uint256 nonce)");
        bytes32 hashStruct_mail = keccak256(abi.encode(
            typeHash_mail,
            keccak256("practice"),
            alice,
            bob,
            0
        ));
        signed_data01 = keccak256(abi.encodePacked(hex"1901", hashStruct_EIP712Domain, hashStruct_mail));
    }


    // Signature verification -------------------------------------*/
    // - the problem : signatures creation and verification both are handled at infrasturcture level, but if signatures are handled 
    //   outside the infrastructure, you need to do handle both signature creation and signature verification independently
    // - the solution : create offchain signatures using ECDSA, and include a function in smart contracts that verifies the signature 
    //   using version 00 of eip191
    function verify(address owner, bytes calldata data, uint8 v, bytes32 r, bytes32 s) public view returns (bool success) {
        bytes32 signed_data = keccak256(abi.encodePacked(hex"1900", address(this), data));
        address signer = ecrecover(signed_data, v, r, s);
        require(signer == owner, "unauthorized");
        return true;
    }


    // EIP2612 signed approvals for erc20 tokens ------------------*/
    // - trivia
    //      - a practical application of independent signature handling (offchain signature creation and onchain signature verification)
    //      - it de-couples ERC20 from msg.sender(builtin signature handling) by handling signatures independently
    //      - A common use case of permit design pattern has a relayer submit a permit order on behalf of the owner.
    // - the problem : ERC20 operation is attached to msg.sender for its builtin signature handling
    // - the solution : decouple ERC20 from msg.sender by implementing signature handling independently 
    //      - offchain signature creation (v, r, s): ECDSA(signed_data, pvtKey)
    //      - submit the order(owner, spender, value, deadline) and the signature (v, r, s) to relayer that will inititate the permit method on token
    //      - create signed_data that will be used in signer extraction: 191, 712, 2612
    //      - extract signer: ecrecover(signed_data, v, r, s)
    //      - verify if the signature is of owner from the order : require(signer == owner, "don't touch someone else's money")
    //      - perform the approve action i.e update allowance for the given order
    // - implementation : Compliant contracts must implement 3 new functions in addition to EIP-20:
    //      - function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external{
    //            // 1. signer recovery 
    //            // 2. verification
    //            // 3. allowance update 
    //        }
    //      - function nonces(address owner) external view returns (uint)
    //      - function DOMAIN_SEPARATOR() external view returns (bytes32)
    // - pros :
    //      - Gasless approves
    //          - Users can approve token transfers without paying gas fees upfront.
    //          - instead of calling approve(), users sign a message off-chain, which is later submitted by the relayer.
    //      - Uniswap and Aave use EIP-2612 to streamline token approvals
    //          - No need for two transactions (approve() + transferFrom()), improving user experience.
    //          - Ideal for onboarding new users without requiring ETH for gas.
    //      - Security notes
    //          - reducing frontrunning risks
    //          - Uses eip712 domainSeperator, preventing signature malleability issues.
    //          - deadline param prevents issues like "stuck approvals" 
    //          - nonces gives replay protection
    //          - Since the ecrecover precompile fails silently and just returns the zero address as signer when given malformed messages, 
    //            it is important to ensure owner != address(0) to avoid permit from creating an approval to spend “zombie funds” belong 
    //            to the zero address.
    //          - The standard EIP-20 race condition for approvals (SWC-114) applies to permit as well
    //          - If the DOMAIN_SEPARATOR contains the chainId and is defined at contract deployment instead of reconstructed for every signature, 
    //            there is a risk of possible replay attacks between chains in the event of a future chain split.
    mapping(address => mapping(address => uint256)) public allowance;
    mapping(address => uint256) public nonces;
    event Approval(address indexed owner, address indexed spender, uint256 amount);
    function permit(
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public virtual {
        require(deadline >= block.timestamp, "PERMIT_DEADLINE_EXPIRED");

        // Unchecked because the only math done is incrementing
        // the owner's nonce which cannot realistically overflow.
        unchecked {
            address recoveredAddress = ecrecover(
                keccak256(
                    abi.encodePacked(
                        "\x19\x01",
                        DOMAIN_SEPARATOR(),
                        keccak256(
                            abi.encode(
                                keccak256(
                                    "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"
                                ),
                                owner,
                                spender,
                                value,
                                nonces[owner]++,
                                deadline
                            )
                        )
                    )
                ),
                v,
                r,
                s
            );

            require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNER");

            allowance[recoveredAddress][spender] = value;
        }

        emit Approval(owner, spender, value);
    }
    
    uint256 internal immutable INITIAL_CHAIN_ID = block.chainid;
    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();
    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {
        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();//in case the chain bifurgates, chainids may differ
    }
    function computeDomainSeparator() internal view virtual returns (bytes32) {
        return
            keccak256(
                abi.encode(
                    keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
                    keccak256("MockERC20"),
                    keccak256("1"),
                    block.chainid,
                    address(this)
                )
            );
    }

    // EIP1271 contract signature verification @todo
    // - the problem : 
    // - the solution : 
    // - implementation : 
    // - properties : 
    // - use cases :


    // commit reveal scheme @todo
    // - the problem : 
    // - the solution : 
    // - implementation : 
    // - properties : 
    // - use cases :

    // merkle trees @todo
    // - the problem : 
    // - the solution : 
    // - implementation : 
    // - properties : 
    // - use cases :

    // randomness generation (chainlink) @todo
    // - the problem : 
    // - the solution : 
    // - implementation : 
    // - properties : 
    // - use cases :

}
